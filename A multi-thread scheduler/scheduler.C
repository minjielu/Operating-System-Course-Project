/*
 File: scheduler.C

 Author:
 Date  :

 */

/*--------------------------------------------------------------------------*/
/* DEFINES */
/*--------------------------------------------------------------------------*/

/* -- (none) -- */

/*--------------------------------------------------------------------------*/
/* INCLUDES */
/*--------------------------------------------------------------------------*/

#include "scheduler.H"
#include "thread.H"
#include "console.H"
#include "utils.H"
#include "assert.H"
#include "simple_keyboard.H"
#include "machine.H"
#include "interrupts.H"

/*--------------------------------------------------------------------------*/
/* DATA STRUCTURES */
/*--------------------------------------------------------------------------*/

/* -- (none) -- */

/*--------------------------------------------------------------------------*/
/* CONSTANTS */
/*--------------------------------------------------------------------------*/

/* -- (none) -- */

/*--------------------------------------------------------------------------*/
/* FORWARDS */
/*--------------------------------------------------------------------------*/

/* -- (none) -- */

/*--------------------------------------------------------------------------*/
/* METHODS FOR CLASS   S c h e d u l e r  */
/*--------------------------------------------------------------------------*/

Scheduler * Scheduler::last_scheduler = NULL;

Scheduler::Scheduler() {
  start_of_queue = NULL;
  end_of_queue = NULL;
  pre_scheduler = last_scheduler;
  last_scheduler = this;
  thread_list = NULL;
  Console::puts("Constructed Scheduler.\n");
}

void Scheduler::yield() {
  // Dispatch to the thread in the front of the ready queue.
  Thread * queue_front = start_of_queue;
  start_of_queue = queue_front -> next_thread;
  queue_front -> next_thread = NULL;
  Thread::dispatch_to(queue_front);
}

void Scheduler::resume(Thread * _thread) {
  // If there is no thread in the ready queue.
  Machine::disable_interrupts();
  if(start_of_queue == NULL) {
    start_of_queue = _thread;
    end_of_queue = _thread;
  }
  // Add the thread to the end if the ready queue.
  else {
    end_of_queue -> next_thread = _thread;
    end_of_queue = _thread;
  }
}

void Scheduler::add(Thread * _thread) {
  // If there is no thread in the ready queue.
  if(start_of_queue == NULL) {
    start_of_queue = _thread;
    end_of_queue = _thread;
    _thread -> pre_thread = thread_list;
    thread_list = _thread;
  }
  // Add a new thread to the end of the ready queue.
  else{
    end_of_queue -> next_thread = _thread;
    end_of_queue = _thread;
    _thread -> pre_thread = thread_list;
    thread_list = _thread;
  }
}

void Scheduler::terminate(Thread * _thread) {
  yield();
}

void Scheduler::terminate_thread(Thread * _thread) {
  Scheduler * scheduler_pt = last_scheduler;
  /*
  Thread * thread_pt = NULL;
  while(scheduler_pt != NULL && thread_pt == NULL) {
    thread_pt = scheduler_pt -> thread_list;
    while(thread_pt != NULL && (thread_pt -> ThreadId() != _thread -> ThreadId())) {
	Console::puti(thread_pt -> ThreadId());
	thread_pt = thread_pt -> pre_thread;
    }
    if(thread_pt == NULL)  scheduler_pt = scheduler_pt -> pre_scheduler;
  }
*/
  scheduler_pt -> terminate(_thread);
}

void Scheduler::preempt_thread(Thread * _thread) {
  last_scheduler -> resume(_thread);
  // Mark the thread as going to return from a preemption in the future.
  _thread -> return_from_preemption = true;

  // Notice the PIC that the interrupt is handled.

  /* Check if the interrupt was generated by the slave interrupt controller. 
       If so, send an End-of-Interrupt (EOI) message to the slave controller. */

  /* Send an EOI message to the master interrupt controller. */
  Machine::outportb(0x20, 0x20);
  
  Console::puts("Thread: ");Console::puti(Thread::CurrentThread() -> ThreadId());Console::puts(" is preempted.\n");

  last_scheduler -> yield();
}
